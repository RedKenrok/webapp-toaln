{
  "version": 3,
  "sources": ["../src/sw.js"],
  "sourcesContent": ["\nconst CACHE_NAME = 'cache-v1'\n\nconst sendMessageToClients = (\n  message,\n) => {\n  self.clients.matchAll()\n    .then(clients => {\n      clients.forEach(\n        client => client.postMessage(message),\n      )\n    })\n}\n\nconst updateCacheAndNotify = async (\n  request,\n  cachedResponse,\n) => {\n  const networkResponse = await fetch(\n    request.clone(),\n  )\n  if (\n    !networkResponse\n    || networkResponse.status !== 200\n  ) {\n    return\n  }\n\n  const cache = await caches.open(CACHE_NAME)\n  const responseForCache = networkResponse.clone()\n\n  let changed = true\n  // Compare cached response to new response.\n  if (cachedResponse) {\n    const responseForComparison = networkResponse.clone()\n\n    // Compare the new response with the cached one.\n    const [newContent, cachedContent] = await Promise.all([\n      responseForComparison.text(),\n      cachedResponse.text(),\n    ])\n\n    changed = newContent !== cachedContent\n  }\n  // If it  has changed update the cache and notify the main thread.\n  if (changed) {\n    await cache.put(request, responseForCache)\n\n    sendMessageToClients({\n      type: 'cacheUpdate',\n      url: request.url,\n    })\n  }\n}\n\n// Clean up old caches during the activation phase.\nself.addEventListener('activate', event => {\n  event.waitUntil(\n    caches.keys()\n      .then(cacheNames =>\n        Promise.all(\n          cacheNames.map(name => {\n            if (name !== CACHE_NAME) {\n              return caches.delete(name)\n            }\n          })\n        )\n      )\n  )\n  self.clients.claim()\n})\n\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request)\n      .then(cachedResponse => {\n        // Trigger background update.\n        event.waitUntil(\n          updateCacheAndNotify(event.request, (\n            cachedResponse\n              ? cachedResponse.clone()\n              : cachedResponse\n          ))\n        )\n        // Return cached response immediately if available.\n        return (\n          cachedResponse\n          || fetch(event.request)\n        )\n      })\n  )\n})\n\nconst FILES_TO_CACHE = (\n  process.env.NODE_ENV === 'production'\n    ? [\n      './index.html',\n      './app.min.js',\n      './app.min.css',\n      './manifest.json',\n    ]\n    : []\n)\n\n// Cache the files during the installation phase.\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => cache.addAll(FILES_TO_CACHE))\n  )\n  self.skipWaiting()\n})\n"],
  "mappings": ";AACA,IAAM,aAAa;AAEnB,IAAM,uBAAuB,CAC3B,YACG;AACH,OAAK,QAAQ,SAAS,EACnB,KAAK,aAAW;AACf,YAAQ;AAAA,MACN,YAAU,OAAO,YAAY,OAAO;AAAA,IACtC;AAAA,EACF,CAAC;AACL;AAEA,IAAM,uBAAuB,OAC3B,SACA,mBACG;AACH,QAAM,kBAAkB,MAAM;AAAA,IAC5B,QAAQ,MAAM;AAAA,EAChB;AACA,MACE,CAAC,mBACE,gBAAgB,WAAW,KAC9B;AACA;AAAA,EACF;AAEA,QAAM,QAAQ,MAAM,OAAO,KAAK,UAAU;AAC1C,QAAM,mBAAmB,gBAAgB,MAAM;AAE/C,MAAI,UAAU;AAEd,MAAI,gBAAgB;AAClB,UAAM,wBAAwB,gBAAgB,MAAM;AAGpD,UAAM,CAAC,YAAY,aAAa,IAAI,MAAM,QAAQ,IAAI;AAAA,MACpD,sBAAsB,KAAK;AAAA,MAC3B,eAAe,KAAK;AAAA,IACtB,CAAC;AAED,cAAU,eAAe;AAAA,EAC3B;AAEA,MAAI,SAAS;AACX,UAAM,MAAM,IAAI,SAAS,gBAAgB;AAEzC,yBAAqB;AAAA,MACnB,MAAM;AAAA,MACN,KAAK,QAAQ;AAAA,IACf,CAAC;AAAA,EACH;AACF;AAGA,KAAK,iBAAiB,YAAY,WAAS;AACzC,QAAM;AAAA,IACJ,OAAO,KAAK,EACT;AAAA,MAAK,gBACJ,QAAQ;AAAA,QACN,WAAW,IAAI,UAAQ;AACrB,cAAI,SAAS,YAAY;AACvB,mBAAO,OAAO,OAAO,IAAI;AAAA,UAC3B;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACJ;AACA,OAAK,QAAQ,MAAM;AACrB,CAAC;AAED,KAAK,iBAAiB,SAAS,WAAS;AACtC,QAAM;AAAA,IACJ,OAAO,MAAM,MAAM,OAAO,EACvB,KAAK,oBAAkB;AAEtB,YAAM;AAAA,QACJ,qBAAqB,MAAM,SACzB,iBACI,eAAe,MAAM,IACrB,cACL;AAAA,MACH;AAEA,aACE,kBACG,MAAM,MAAM,OAAO;AAAA,IAE1B,CAAC;AAAA,EACL;AACF,CAAC;AAED,IAAM,iBACJ,QACI;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,IACE,CAAC;AAIP,KAAK,iBAAiB,WAAW,WAAS;AACxC,QAAM;AAAA,IACJ,OAAO,KAAK,UAAU,EACnB,KAAK,WAAS,MAAM,OAAO,cAAc,CAAC;AAAA,EAC/C;AACA,OAAK,YAAY;AACnB,CAAC;",
  "names": []
}
