{
  "version": 3,
  "sources": ["../src/sw.js"],
  "sourcesContent": ["\nconst CACHE_NAME = 'cache-v1'\n\nconst sendMessageToClients = (\n  message,\n) => {\n  self.clients.matchAll()\n    .then(clients => {\n      clients.forEach(\n        client => client.postMessage(message),\n      )\n    })\n}\n\nconst updateCacheAndNotify = async (\n  request,\n  cachedResponse,\n) => {\n  const networkResponse = await fetch(\n    request.clone(),\n  )\n  if (\n    !networkResponse\n    || networkResponse.status !== 200\n  ) {\n    return\n  }\n\n  const cache = await caches.open(CACHE_NAME)\n  const responseForCache = networkResponse.clone()\n\n  let changed = true\n  // Compare cached response to new response.\n  if (cachedResponse) {\n    const responseForComparison = networkResponse.clone()\n\n    // Compare the new response with the cached one.\n    const [newContent, cachedContent] = await Promise.all([\n      responseForComparison.text(),\n      cachedResponse.text(),\n    ])\n\n    changed = newContent !== cachedContent\n  }\n  // If it  has changed update the cache and notify the main thread.\n  if (changed) {\n    await cache.put(request, responseForCache)\n\n    sendMessageToClients({\n      type: 'cacheUpdate',\n      url: request.url,\n    })\n  }\n}\n\n// Clean up old caches during the activation phase.\nself.addEventListener('activate', event => {\n  event.waitUntil(\n    caches.keys()\n      .then(cacheNames =>\n        Promise.all(\n          cacheNames.map(name => {\n            if (name !== CACHE_NAME) {\n              return caches.delete(name)\n            }\n          })\n        )\n      )\n  )\n  self.clients.claim()\n})\n\nself.addEventListener('fetch', event => {\n  process.env.NODE_ENV === 'production'\n    ? event.respondWith(\n      caches.match(event.request)\n        .then(cachedResponse => {\n          // Trigger background update.\n          event.waitUntil(\n            updateCacheAndNotify(event.request, (\n              cachedResponse\n                ? cachedResponse.clone()\n                : cachedResponse\n            ))\n          )\n          // Return cached response immediately if available.\n          return (\n            cachedResponse\n            || fetch(event.request)\n          )\n        })\n    )\n    : fetch(event.request)\n})\n\nconst FILES_TO_CACHE = (\n  process.env.NODE_ENV === 'production'\n    ? [\n      './index.html',\n      './app.min.css',\n      './app.min.js',\n      './manifest.json',\n      './sw.min.js',\n    ]\n    : []\n)\n\n// Cache the files during the installation phase.\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => cache.addAll(FILES_TO_CACHE))\n  )\n  self.skipWaiting()\n})\n"],
  "mappings": ";AACA,IAAM,aAAa;AAuDnB,KAAK,iBAAiB,YAAY,WAAS;AACzC,QAAM;AAAA,IACJ,OAAO,KAAK,EACT;AAAA,MAAK,gBACJ,QAAQ;AAAA,QACN,WAAW,IAAI,UAAQ;AACrB,cAAI,SAAS,YAAY;AACvB,mBAAO,OAAO,OAAO,IAAI;AAAA,UAC3B;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACJ;AACA,OAAK,QAAQ,MAAM;AACrB,CAAC;AAED,KAAK,iBAAiB,SAAS,WAAS;AACtC,UACI,MAAM;AAAA,IACN,OAAO,MAAM,MAAM,OAAO,EACvB,KAAK,oBAAkB;AAEtB,YAAM;AAAA,QACJ,qBAAqB,MAAM,SACzB,iBACI,eAAe,MAAM,IACrB,cACL;AAAA,MACH;AAEA,aACE,kBACG,MAAM,MAAM,OAAO;AAAA,IAE1B,CAAC;AAAA,EACL,IACE,MAAM,MAAM,OAAO;AACzB,CAAC;AAED,IAAM,iBACJ,QACI;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,IACE,CAAC;AAIP,KAAK,iBAAiB,WAAW,WAAS;AACxC,QAAM;AAAA,IACJ,OAAO,KAAK,UAAU,EACnB,KAAK,WAAS,MAAM,OAAO,cAAc,CAAC;AAAA,EAC/C;AACA,OAAK,YAAY;AACnB,CAAC;",
  "names": []
}
